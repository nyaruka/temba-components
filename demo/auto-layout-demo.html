<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flow Editor Auto Layout Demo</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        
        .demo-container {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .demo-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }
        
        .demo-description {
            margin-bottom: 15px;
            color: #666;
            line-height: 1.4;
        }
        
        .flow-canvas {
            position: relative;
            width: 100%;
            height: 400px;
            background-color: #f9f9f9;
            background-image: 
                linear-gradient(0deg, transparent 24%, rgba(61, 177, 255, 0.15) 25%, rgba(61, 177, 255, 0.15) 26%, transparent 27%, transparent 74%, rgba(61, 177, 255, 0.15) 75%, rgba(61, 177, 255, 0.15) 76%, transparent 77%, transparent),
                linear-gradient(90deg, transparent 24%, rgba(61, 177, 255, 0.15) 25%, rgba(61, 177, 255, 0.15) 26%, transparent 27%, transparent 74%, rgba(61, 177, 255, 0.15) 75%, rgba(61, 177, 255, 0.15) 76%, transparent 77%, transparent);
            background-size: 40px 40px;
            background-position: 10px 10px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .flow-node {
            position: absolute;
            width: 200px;
            height: 80px;
            background-color: #fff;
            border: 2px solid #007acc;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #007acc;
            cursor: move;
            user-select: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .flow-node:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transform: translateY(-1px);
        }
        
        .flow-node.dragging {
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
            transform: scale(1.02);
            z-index: 1000;
        }
        
        .sticky-note {
            position: absolute;
            width: 200px;
            height: 100px;
            background-color: #fef08a;
            border: 1px solid #facc15;
            border-radius: 8px;
            padding: 10px;
            box-sizing: border-box;
            cursor: move;
            user-select: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            font-size: 12px;
            color: #451a03;
        }
        
        .sticky-note:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        
        .sticky-note.dragging {
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
            transform: scale(1.02);
            z-index: 1000;
        }
        
        .instructions {
            background: #e8f4fd;
            border: 1px solid #b3d9f2;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .instructions h3 {
            margin-top: 0;
            color: #0066cc;
        }
        
        .instructions ul {
            margin-bottom: 0;
        }
        
        .feature-list {
            background: #f0f9ff;
            border: 1px solid #cce7ff;
            border-radius: 4px;
            padding: 15px;
            margin-top: 20px;
        }
        
        .feature-list h3 {
            margin-top: 0;
            color: #0066cc;
        }
        
        .feature-list ul {
            margin-bottom: 0;
        }
        
        .feature-list li {
            margin-bottom: 5px;
        }
        
        .reset-button {
            background: #007acc;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 10px;
        }
        
        .reset-button:hover {
            background: #005a9e;
        }
    </style>
</head>
<body>
    <h1>Flow Editor Auto Layout Demo</h1>
    
    <div class="instructions">
        <h3>How to Test Auto Layout</h3>
        <ul>
            <li><strong>Drag and Drop:</strong> Click and drag any blue node or yellow sticky note</li>
            <li><strong>Create Collisions:</strong> Drop a node on top of another node or sticky note</li>
            <li><strong>Watch Auto Layout:</strong> Observe how overlapping items automatically move to make room</li>
            <li><strong>Grid Snapping:</strong> All final positions snap to a 20px grid</li>
            <li><strong>Movement Rules:</strong> Items can move in any direction (right, down, left, up) to find the best position</li>
        </ul>
    </div>
    
    <div class="demo-container">
        <div class="demo-title">Auto Layout Demo Canvas</div>
        <div class="demo-description">
            Try dragging the blue nodes or yellow sticky notes to create overlapping situations. 
            The auto-layout algorithm will automatically resolve collisions by moving items in the optimal direction with cascading collision handling.
        </div>
        
        <div class="flow-canvas" id="canvas">
            <div class="flow-node" style="left: 100px; top: 100px;" data-uuid="node1">
                Node A
            </div>
            <div class="flow-node" style="left: 320px; top: 100px;" data-uuid="node2">
                Node B
            </div>
            <div class="flow-node" style="left: 100px; top: 220px;" data-uuid="node3">
                Node C
            </div>
            <div class="sticky-note" style="left: 320px; top: 220px;" data-uuid="sticky1">
                <strong>Sticky Note</strong><br>
                This is a sticky note that can also be moved around.
            </div>
            <div class="sticky-note" style="left: 540px; top: 100px;" data-uuid="sticky2">
                <strong>Another Note</strong><br>
                Try dragging this over other items!
            </div>
        </div>
        
        <button class="reset-button" onclick="resetPositions()">Reset Positions</button>
    </div>
    
    <div class="feature-list">
        <h3>Auto Layout Features Demonstrated</h3>
        <ul>
            <li>✅ <strong>Collision Detection:</strong> Automatically detects when dragged items overlap with existing items</li>
            <li>✅ <strong>Smart Movement:</strong> Moves items in optimal directions (right, down, left, up) considering distance and flow layout</li>
            <li>✅ <strong>Cascading Moves:</strong> When moving one item creates a new collision, the algorithm handles it recursively</li>
            <li>✅ <strong>Grid Snapping:</strong> All final positions are snapped to a 20px grid for clean alignment</li>
            <li>✅ <strong>Minimal Changes:</strong> Uses the smallest possible movements to resolve collisions</li>
            <li>✅ <strong>Order Preservation:</strong> Maintains the relative order and structure of the flow</li>
            <li>✅ <strong>Mixed Types:</strong> Works with both flow nodes and sticky notes</li>
        </ul>
    </div>

    <script>
        // Simplified auto-layout implementation for demo
        class AutoLayoutDemo {
            constructor() {
                this.isDragging = false;
                this.currentElement = null;
                this.startPos = { x: 0, y: 0 };
                this.elementStartPos = { x: 0, y: 0 };
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                const canvas = document.getElementById('canvas');
                const items = canvas.querySelectorAll('.flow-node, .sticky-note');
                
                items.forEach(item => {
                    item.addEventListener('mousedown', this.handleMouseDown.bind(this));
                });
                
                document.addEventListener('mousemove', this.handleMouseMove.bind(this));
                document.addEventListener('mouseup', this.handleMouseUp.bind(this));
            }
            
            handleMouseDown(e) {
                this.isDragging = true;
                this.currentElement = e.target;
                this.startPos = { x: e.clientX, y: e.clientY };
                
                const rect = this.currentElement.getBoundingClientRect();
                const canvasRect = document.getElementById('canvas').getBoundingClientRect();
                this.elementStartPos = {
                    x: rect.left - canvasRect.left,
                    y: rect.top - canvasRect.top
                };
                
                this.currentElement.classList.add('dragging');
                e.preventDefault();
            }
            
            handleMouseMove(e) {
                if (!this.isDragging || !this.currentElement) return;
                
                const deltaX = e.clientX - this.startPos.x;
                const deltaY = e.clientY - this.startPos.y;
                
                const newX = this.elementStartPos.x + deltaX;
                const newY = this.elementStartPos.y + deltaY;
                
                this.currentElement.style.left = newX + 'px';
                this.currentElement.style.top = newY + 'px';
            }
            
            handleMouseUp(e) {
                if (!this.isDragging || !this.currentElement) return;
                
                this.currentElement.classList.remove('dragging');
                
                const deltaX = e.clientX - this.startPos.x;
                const deltaY = e.clientY - this.startPos.y;
                
                const newX = this.snapToGrid(this.elementStartPos.x + deltaX);
                const newY = this.snapToGrid(this.elementStartPos.y + deltaY);
                
                // Set snapped position
                this.currentElement.style.left = newX + 'px';
                this.currentElement.style.top = newY + 'px';
                
                // Simulate auto-layout collision resolution
                this.resolveCollisions(this.currentElement, newX, newY);
                
                this.isDragging = false;
                this.currentElement = null;
            }
            
            snapToGrid(value) {
                return Math.round(value / 20) * 20;
            }
            
            resolveCollisions(droppedElement, droppedX, droppedY) {
                const canvas = document.getElementById('canvas');
                const allItems = Array.from(canvas.querySelectorAll('.flow-node, .sticky-note'));
                
                // Create initial layout of all items with their current positions
                const itemLayouts = allItems.map(item => ({
                    element: item,
                    uuid: item.getAttribute('data-uuid'),
                    position: {
                        left: parseInt(item.style.left),
                        top: parseInt(item.style.top)
                    },
                    boundingBox: {
                        left: parseInt(item.style.left),
                        top: parseInt(item.style.top),
                        right: parseInt(item.style.left) + item.offsetWidth,
                        bottom: parseInt(item.style.top) + item.offsetHeight
                    }
                }));

                // Update the dropped element's position
                const droppedLayout = itemLayouts.find(layout => layout.element === droppedElement);
                if (droppedLayout) {
                    droppedLayout.position = { left: droppedX, top: droppedY };
                    droppedLayout.boundingBox = {
                        left: droppedX,
                        top: droppedY,
                        right: droppedX + droppedElement.offsetWidth,
                        bottom: droppedY + droppedElement.offsetHeight
                    };
                }

                const moves = new Map();
                
                // Iterative collision resolution to handle cascading collisions
                let hasChanges = true;
                let maxIterations = 10;
                let iteration = 0;
                
                while (hasChanges && iteration < maxIterations) {
                    hasChanges = false;
                    iteration++;
                    
                    // Check all items for collisions
                    for (let i = 0; i < itemLayouts.length; i++) {
                        const currentItem = itemLayouts[i];
                        
                        // Find collisions with this item
                        const collisions = itemLayouts.filter((item, index) => 
                            index !== i && 
                            this.hasCollision(currentItem.boundingBox, item.boundingBox)
                        );
                        
                        if (collisions.length > 0) {
                            // Sort collisions by position to handle them consistently
                            const sortedCollisions = collisions.sort((a, b) => {
                                if (Math.abs(a.position.top - b.position.top) < 20) {
                                    return a.position.left - b.position.left;
                                }
                                return a.position.top - b.position.top;
                            });
                            
                            // Resolve collisions - prioritize moving items that haven't been moved yet
                            for (const collidingItem of sortedCollisions) {
                                // Skip if this is the dropped item (it shouldn't be moved)
                                if (collidingItem.element === droppedElement) {
                                    continue;
                                }
                                
                                // Skip if this item has already been moved in this iteration
                                if (moves.has(collidingItem.uuid)) {
                                    continue;
                                }
                                
                                const newPosition = this.findBestPosition(collidingItem, currentItem, itemLayouts);
                                if (newPosition) {
                                    // Record the move
                                    moves.set(collidingItem.uuid, newPosition);
                                    
                                    // Update the item's position in our tracking array
                                    collidingItem.position = newPosition;
                                    collidingItem.boundingBox = {
                                        left: newPosition.left,
                                        top: newPosition.top,
                                        right: newPosition.left + collidingItem.element.offsetWidth,
                                        bottom: newPosition.top + collidingItem.element.offsetHeight
                                    };
                                    hasChanges = true;
                                }
                            }
                        }
                    }
                }
                
                // Apply all moves to the DOM
                moves.forEach((position, uuid) => {
                    const item = canvas.querySelector(`[data-uuid="${uuid}"]`);
                    if (item) {
                        this.animateMove(item, position.left, position.top);
                    }
                });
            }
            
            findBestPosition(itemToMove, blockingItem, allItems) {
                const blockingBox = blockingItem.boundingBox;
                const spacing = 20;
                
                const candidates = [];
                
                // Try right position
                const rightPosition = {
                    left: this.snapToGrid(blockingBox.right + spacing),
                    top: this.snapToGrid(itemToMove.position.top)
                };
                if (!this.wouldCollide(rightPosition, itemToMove.element, allItems)) {
                    const distance = Math.abs(rightPosition.left - itemToMove.position.left) + 
                                   Math.abs(rightPosition.top - itemToMove.position.top);
                    candidates.push({ position: rightPosition, distance, direction: 'right' });
                }
                
                // Try down position
                const belowPosition = {
                    left: this.snapToGrid(itemToMove.position.left),
                    top: this.snapToGrid(blockingBox.bottom + spacing)
                };
                if (!this.wouldCollide(belowPosition, itemToMove.element, allItems)) {
                    const distance = Math.abs(belowPosition.left - itemToMove.position.left) + 
                                   Math.abs(belowPosition.top - itemToMove.position.top);
                    candidates.push({ position: belowPosition, distance, direction: 'down' });
                }
                
                // Try left position (only if it doesn't go negative)
                const leftPosition = {
                    left: this.snapToGrid(Math.max(0, blockingBox.left - spacing - itemToMove.element.offsetWidth)),
                    top: this.snapToGrid(itemToMove.position.top)
                };
                if (leftPosition.left >= 0 && !this.wouldCollide(leftPosition, itemToMove.element, allItems)) {
                    const distance = Math.abs(leftPosition.left - itemToMove.position.left) + 
                                   Math.abs(leftPosition.top - itemToMove.position.top);
                    candidates.push({ position: leftPosition, distance, direction: 'left' });
                }
                
                // Try up position (only if it doesn't go negative)
                const abovePosition = {
                    left: this.snapToGrid(itemToMove.position.left),
                    top: this.snapToGrid(Math.max(0, blockingBox.top - spacing - itemToMove.element.offsetHeight))
                };
                if (abovePosition.top >= 0 && !this.wouldCollide(abovePosition, itemToMove.element, allItems)) {
                    const distance = Math.abs(abovePosition.left - itemToMove.position.left) + 
                                   Math.abs(abovePosition.top - itemToMove.position.top);
                    candidates.push({ position: abovePosition, distance, direction: 'up' });
                }
                
                if (candidates.length === 0) {
                    // Fallback to right position
                    return {
                        left: this.snapToGrid(blockingBox.right + spacing),
                        top: this.snapToGrid(itemToMove.position.top)
                    };
                }
                
                // Sort by distance, then by direction preference (right > down > left > up)
                candidates.sort((a, b) => {
                    const distanceDiff = Math.abs(a.distance - b.distance);
                    if (distanceDiff <= 100) {
                        const directionPriority = { right: 1, down: 2, left: 3, up: 4 };
                        return directionPriority[a.direction] - directionPriority[b.direction];
                    }
                    return a.distance - b.distance;
                });
                
                return candidates[0].position;
            }
            
            wouldCollide(position, element, allItems) {
                const testBox = {
                    left: position.left,
                    top: position.top,
                    right: position.left + element.offsetWidth,
                    bottom: position.top + element.offsetHeight
                };
                
                return allItems.some(item => 
                    item.element !== element && 
                    this.hasCollision(testBox, item.boundingBox)
                );
            }
            
            animateMove(item, left, top) {
                item.style.transition = 'all 0.3s ease';
                item.style.left = left + 'px';
                item.style.top = top + 'px';
                setTimeout(() => {
                    item.style.transition = '';
                }, 300);
            }
            
            hasCollision(rect1, rect2) {
                return !(rect1.right <= rect2.left || 
                        rect1.left >= rect2.right || 
                        rect1.bottom <= rect2.top || 
                        rect1.top >= rect2.bottom);
            }
        }
        
        // Initialize the demo
        const demo = new AutoLayoutDemo();
        
        function resetPositions() {
            const positions = [
                { selector: '[data-uuid="node1"]', left: 100, top: 100 },
                { selector: '[data-uuid="node2"]', left: 320, top: 100 },
                { selector: '[data-uuid="node3"]', left: 100, top: 220 },
                { selector: '[data-uuid="sticky1"]', left: 320, top: 220 },
                { selector: '[data-uuid="sticky2"]', left: 540, top: 100 }
            ];
            
            positions.forEach(pos => {
                const element = document.querySelector(pos.selector);
                if (element) {
                    element.style.left = pos.left + 'px';
                    element.style.top = pos.top + 'px';
                    element.style.transition = 'all 0.3s ease';
                    setTimeout(() => {
                        element.style.transition = '';
                    }, 300);
                }
            });
        }
    </script>
</body>
</html>