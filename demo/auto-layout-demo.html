<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flow Editor Auto Layout Demo</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        
        .demo-container {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .demo-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }
        
        .demo-description {
            margin-bottom: 15px;
            color: #666;
            line-height: 1.4;
        }
        
        .flow-canvas {
            position: relative;
            width: 100%;
            height: 400px;
            background-color: #f9f9f9;
            background-image: 
                linear-gradient(0deg, transparent 24%, rgba(61, 177, 255, 0.15) 25%, rgba(61, 177, 255, 0.15) 26%, transparent 27%, transparent 74%, rgba(61, 177, 255, 0.15) 75%, rgba(61, 177, 255, 0.15) 76%, transparent 77%, transparent),
                linear-gradient(90deg, transparent 24%, rgba(61, 177, 255, 0.15) 25%, rgba(61, 177, 255, 0.15) 26%, transparent 27%, transparent 74%, rgba(61, 177, 255, 0.15) 75%, rgba(61, 177, 255, 0.15) 76%, transparent 77%, transparent);
            background-size: 40px 40px;
            background-position: 10px 10px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .flow-node {
            position: absolute;
            width: 200px;
            height: 80px;
            background-color: #fff;
            border: 2px solid #007acc;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #007acc;
            cursor: move;
            user-select: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .flow-node:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transform: translateY(-1px);
        }
        
        .flow-node.dragging {
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
            transform: scale(1.02);
            z-index: 1000;
        }
        
        .sticky-note {
            position: absolute;
            width: 200px;
            height: 100px;
            background-color: #fef08a;
            border: 1px solid #facc15;
            border-radius: 8px;
            padding: 10px;
            box-sizing: border-box;
            cursor: move;
            user-select: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            font-size: 12px;
            color: #451a03;
        }
        
        .sticky-note:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        
        .sticky-note.dragging {
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
            transform: scale(1.02);
            z-index: 1000;
        }
        
        .instructions {
            background: #e8f4fd;
            border: 1px solid #b3d9f2;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .instructions h3 {
            margin-top: 0;
            color: #0066cc;
        }
        
        .instructions ul {
            margin-bottom: 0;
        }
        
        .feature-list {
            background: #f0f9ff;
            border: 1px solid #cce7ff;
            border-radius: 4px;
            padding: 15px;
            margin-top: 20px;
        }
        
        .feature-list h3 {
            margin-top: 0;
            color: #0066cc;
        }
        
        .feature-list ul {
            margin-bottom: 0;
        }
        
        .feature-list li {
            margin-bottom: 5px;
        }
        
        .reset-button {
            background: #007acc;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 10px;
        }
        
        .reset-button:hover {
            background: #005a9e;
        }
    </style>
</head>
<body>
    <h1>Flow Editor Auto Layout Demo</h1>
    
    <div class="instructions">
        <h3>How to Test Auto Layout</h3>
        <ul>
            <li><strong>Drag and Drop:</strong> Click and drag any blue node or yellow sticky note</li>
            <li><strong>Create Collisions:</strong> Drop a node on top of another node or sticky note</li>
            <li><strong>Watch Auto Layout:</strong> Observe how overlapping items automatically move to make room</li>
            <li><strong>Grid Snapping:</strong> All final positions snap to a 20px grid</li>
            <li><strong>Movement Rules:</strong> Items can move in any direction (right, down, left, up) to find the best position</li>
        </ul>
    </div>
    
    <div class="demo-container">
        <div class="demo-title">Auto Layout Demo Canvas</div>
        <div class="demo-description">
            Try dragging the blue nodes or yellow sticky notes to create overlapping situations. 
            The auto-layout algorithm will automatically resolve collisions by moving items in the optimal direction with cascading collision handling.
        </div>
        
        <div class="flow-canvas" id="canvas">
            <div class="flow-node" style="left: 100px; top: 100px;" data-uuid="node1">
                Node A
            </div>
            <div class="flow-node" style="left: 320px; top: 100px;" data-uuid="node2">
                Node B
            </div>
            <div class="flow-node" style="left: 100px; top: 220px;" data-uuid="node3">
                Node C
            </div>
            <div class="sticky-note" style="left: 320px; top: 220px;" data-uuid="sticky1">
                <strong>Sticky Note</strong><br>
                This is a sticky note that can also be moved around.
            </div>
            <div class="sticky-note" style="left: 540px; top: 100px;" data-uuid="sticky2">
                <strong>Another Note</strong><br>
                Try dragging this over other items!
            </div>
        </div>
        
        <button class="reset-button" onclick="resetPositions()">Reset Positions</button>
    </div>
    
    <div class="feature-list">
        <h3>Auto Layout Features Demonstrated</h3>
        <ul>
            <li>✅ <strong>Collision Detection:</strong> Automatically detects when dragged items overlap with existing items</li>
            <li>✅ <strong>Smart Movement:</strong> Moves items in optimal directions (right, down, left, up) considering distance and flow layout</li>
            <li>✅ <strong>Cascading Moves:</strong> When moving one item creates a new collision, the algorithm handles it recursively</li>
            <li>✅ <strong>Grid Snapping:</strong> All final positions are snapped to a 20px grid for clean alignment</li>
            <li>✅ <strong>Minimal Changes:</strong> Uses the smallest possible movements to resolve collisions</li>
            <li>✅ <strong>Order Preservation:</strong> Maintains the relative order and structure of the flow</li>
            <li>✅ <strong>Mixed Types:</strong> Works with both flow nodes and sticky notes</li>
        </ul>
    </div>

    <script>
        // Simplified auto-layout implementation for demo
        class AutoLayoutDemo {
            constructor() {
                this.isDragging = false;
                this.currentElement = null;
                this.startPos = { x: 0, y: 0 };
                this.elementStartPos = { x: 0, y: 0 };
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                const canvas = document.getElementById('canvas');
                const items = canvas.querySelectorAll('.flow-node, .sticky-note');
                
                items.forEach(item => {
                    item.addEventListener('mousedown', this.handleMouseDown.bind(this));
                });
                
                document.addEventListener('mousemove', this.handleMouseMove.bind(this));
                document.addEventListener('mouseup', this.handleMouseUp.bind(this));
            }
            
            handleMouseDown(e) {
                this.isDragging = true;
                this.currentElement = e.target;
                this.startPos = { x: e.clientX, y: e.clientY };
                
                const rect = this.currentElement.getBoundingClientRect();
                const canvasRect = document.getElementById('canvas').getBoundingClientRect();
                this.elementStartPos = {
                    x: rect.left - canvasRect.left,
                    y: rect.top - canvasRect.top
                };
                
                this.currentElement.classList.add('dragging');
                e.preventDefault();
            }
            
            handleMouseMove(e) {
                if (!this.isDragging || !this.currentElement) return;
                
                const deltaX = e.clientX - this.startPos.x;
                const deltaY = e.clientY - this.startPos.y;
                
                const newX = this.elementStartPos.x + deltaX;
                const newY = this.elementStartPos.y + deltaY;
                
                this.currentElement.style.left = newX + 'px';
                this.currentElement.style.top = newY + 'px';
            }
            
            handleMouseUp(e) {
                if (!this.isDragging || !this.currentElement) return;
                
                this.currentElement.classList.remove('dragging');
                
                const deltaX = e.clientX - this.startPos.x;
                const deltaY = e.clientY - this.startPos.y;
                
                const newX = this.snapToGrid(this.elementStartPos.x + deltaX);
                const newY = this.snapToGrid(this.elementStartPos.y + deltaY);
                
                // Set snapped position
                this.currentElement.style.left = newX + 'px';
                this.currentElement.style.top = newY + 'px';
                
                // Simulate auto-layout collision resolution
                this.resolveCollisions(this.currentElement, newX, newY);
                
                this.isDragging = false;
                this.currentElement = null;
            }
            
            snapToGrid(value) {
                return Math.round(value / 20) * 20;
            }
            
            resolveCollisions(droppedElement, droppedX, droppedY) {
                const canvas = document.getElementById('canvas');
                const allItems = Array.from(canvas.querySelectorAll('.flow-node, .sticky-note'));
                
                // Create initial layout of all items with their current positions
                const itemLayouts = allItems.map(item => ({
                    element: item,
                    uuid: item.getAttribute('data-uuid'),
                    position: {
                        left: parseInt(item.style.left),
                        top: parseInt(item.style.top)
                    },
                    boundingBox: {
                        left: parseInt(item.style.left),
                        top: parseInt(item.style.top),
                        right: parseInt(item.style.left) + item.offsetWidth,
                        bottom: parseInt(item.style.top) + item.offsetHeight
                    }
                }));

                // Update the dropped element's position
                const droppedLayout = itemLayouts.find(layout => layout.element === droppedElement);
                if (droppedLayout) {
                    droppedLayout.position = { left: droppedX, top: droppedY };
                    droppedLayout.boundingBox = {
                        left: droppedX,
                        top: droppedY,
                        right: droppedX + droppedElement.offsetWidth,
                        bottom: droppedY + droppedElement.offsetHeight
                    };
                }

                const moves = new Map();
                
                // Find items that collide with the dropped item
                const collisions = itemLayouts.filter(item => 
                    item.element !== droppedElement && 
                    this.hasCollision(droppedLayout.boundingBox, item.boundingBox)
                );
                
                // For each collision, push the colliding item in the most appropriate direction
                for (const collidingItem of collisions) {
                    const pushDirection = this.determinePushDirection(droppedLayout, collidingItem);
                    const pushedMoves = this.pushItemInDirection(collidingItem, pushDirection, itemLayouts, moves);
                    
                    // Merge the pushed moves
                    pushedMoves.forEach((position, uuid) => {
                        moves.set(uuid, position);
                    });
                }
                
                // Apply all moves to the DOM with animation
                moves.forEach((position, uuid) => {
                    const item = canvas.querySelector(`[data-uuid="${uuid}"]`);
                    if (item) {
                        this.animateMove(item, position.left, position.top);
                    }
                });
            }
            
            determinePushDirection(droppedItem, collidingItem) {
                const droppedBox = droppedItem.boundingBox;
                const collidingBox = collidingItem.boundingBox;
                
                // Calculate the center points
                const droppedCenterX = droppedBox.left + droppedBox.right / 2;
                const droppedCenterY = droppedBox.top + droppedBox.bottom / 2;
                const collidingCenterX = collidingBox.left + collidingBox.right / 2;
                const collidingCenterY = collidingBox.top + collidingBox.bottom / 2;
                
                // Calculate the displacement needed
                const deltaX = collidingCenterX - droppedCenterX;
                const deltaY = collidingCenterY - droppedCenterY;
                
                // Determine primary direction based on the larger displacement
                // Prefer horizontal movement for flow layouts
                const horizontalBias = 1.2; // Slightly prefer horizontal movement
                
                if (Math.abs(deltaX) * horizontalBias > Math.abs(deltaY)) {
                    // Horizontal movement
                    return deltaX > 0 ? 'right' : 'left';
                } else {
                    // Vertical movement
                    return deltaY > 0 ? 'down' : 'up';
                }
            }
            
            pushItemInDirection(itemToPush, direction, allItems, existingMoves) {
                const moves = new Map();
                const spacing = 20;
                
                // Calculate the new position based on direction
                let newPosition;
                
                switch (direction) {
                    case 'right':
                        newPosition = {
                            left: this.snapToGrid(itemToPush.boundingBox.right + spacing),
                            top: this.snapToGrid(itemToPush.position.top)
                        };
                        break;
                    case 'left':
                        newPosition = {
                            left: this.snapToGrid(Math.max(0, itemToPush.boundingBox.left - itemToPush.element.offsetWidth - spacing)),
                            top: this.snapToGrid(itemToPush.position.top)
                        };
                        break;
                    case 'down':
                        newPosition = {
                            left: this.snapToGrid(itemToPush.position.left),
                            top: this.snapToGrid(itemToPush.boundingBox.bottom + spacing)
                        };
                        break;
                    case 'up':
                        newPosition = {
                            left: this.snapToGrid(itemToPush.position.left),
                            top: this.snapToGrid(Math.max(0, itemToPush.boundingBox.top - itemToPush.element.offsetHeight - spacing))
                        };
                        break;
                }
                
                // Ensure the new position is within canvas bounds
                if (newPosition.left < 0) newPosition.left = 0;
                if (newPosition.top < 0) newPosition.top = 0;
                
                // Create the new bounding box for the pushed item
                const newBoundingBox = {
                    left: newPosition.left,
                    top: newPosition.top,
                    right: newPosition.left + itemToPush.element.offsetWidth,
                    bottom: newPosition.top + itemToPush.element.offsetHeight
                };
                
                // Check if this new position would create collisions with other items
                const newCollisions = allItems.filter(item => 
                    item.uuid !== itemToPush.uuid && 
                    !existingMoves.has(item.uuid) && // Don't check against items that are already being moved
                    this.hasCollision(newBoundingBox, item.boundingBox)
                );
                
                // Record this move
                moves.set(itemToPush.uuid, newPosition);
                
                // If there are new collisions, recursively push those items too
                if (newCollisions.length > 0) {
                    for (const newCollision of newCollisions) {
                        // Push in the same direction to maintain order
                        const cascadeMoves = this.pushItemInDirection(newCollision, direction, allItems, new Map([...existingMoves, ...moves]));
                        cascadeMoves.forEach((position, uuid) => {
                            moves.set(uuid, position);
                        });
                    }
                }
                
                // Update the allItems array to reflect the new position for further calculations
                itemToPush.position = newPosition;
                itemToPush.boundingBox = newBoundingBox;
                
                return moves;
            }
            
            animateMove(item, left, top) {
                item.style.transition = 'all 0.3s ease';
                item.style.left = left + 'px';
                item.style.top = top + 'px';
                setTimeout(() => {
                    item.style.transition = '';
                }, 300);
            }
            
            hasCollision(rect1, rect2) {
                return !(rect1.right <= rect2.left || 
                        rect1.left >= rect2.right || 
                        rect1.bottom <= rect2.top || 
                        rect1.top >= rect2.bottom);
            }
        }
        
        // Initialize the demo
        const demo = new AutoLayoutDemo();
        
        function resetPositions() {
            const positions = [
                { selector: '[data-uuid="node1"]', left: 100, top: 100 },
                { selector: '[data-uuid="node2"]', left: 320, top: 100 },
                { selector: '[data-uuid="node3"]', left: 100, top: 220 },
                { selector: '[data-uuid="sticky1"]', left: 320, top: 220 },
                { selector: '[data-uuid="sticky2"]', left: 540, top: 100 }
            ];
            
            positions.forEach(pos => {
                const element = document.querySelector(pos.selector);
                if (element) {
                    element.style.left = pos.left + 'px';
                    element.style.top = pos.top + 'px';
                    element.style.transition = 'all 0.3s ease';
                    setTimeout(() => {
                        element.style.transition = '';
                    }, 300);
                }
            });
        }
    </script>
</body>
</html>